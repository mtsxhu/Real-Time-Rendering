# 第三章 · 图形处理器 The Graphics Processing Unit

## 一、章节介绍及思维导图

&#x20;           这个章节内容主要是介绍GPU架构，讨论GPU如何实现渲染管道、可编程着色器如何操作、以及每个GPU阶段的演变和功能。

## 二、核心内容

&#x20;       GPU从复杂的固定函数管道的可配置实现发展到高度可编程的空白板，开发者可以实现自己的算法。各种类型的可编程着色器是控制GPU的主要手段。为了提高效率，管道的某些部分仍然是可配置的，而不是可编程的，但趋势是可编程和灵活性。GPU通过专注于一组狭窄的高度并行化的任务获得了巨大的速度。他们有专门用于实现z缓冲区的自定义硅，以快速访问纹理图像和其他缓冲区，并找到哪些像素被一个三角形覆盖。

### 2.1 数据并行架构

&#x20;       不同的处理器体系结构使用不同的策略来避免暂停。CPU被优化以处理各种各样的数据结构和大型代码库。CPU可以有多个处理器，但每个处理器主要以串行方式运行代码，有限的 SIMD 向量处理是个例外。为了减少延迟的影响，CPU的大部分芯片都是由快速的本地缓存(local cache)组成的，这些内存中充满了接下来可能需要的数据。CPU也通过使用分支预测、指令重排序、寄存器重命名和缓存预取等聪明的技术来避免暂停。

&#x20;        GPU采用不同的方法。GPU芯片的大部分区域是专门用于一组大型处理器(着色器内核)，通常有数千个。GPU是一种流处理器，它依次处理相似数据的有序集。由于这种相似性，例如，一组顶点或像素，GPU可以以大规模并行方式处理这些数据。另一个重要的因素是，这些调用尽可能独立，这样它们就不需要从相邻的调用获取信息，也不共享可写内存位置。这条规则有时会被打破，以允许新的和有用的功能，但这种异常的代价是潜在的延迟，因为一个处理器可能会等待另一个处理器完成它的工作。

&#x20;       GPU为吞吐量进行了优化，吞吐量定义为数据可处理的最大速率。然而，这种快速处理是有代价的。由于专用于高速缓存内存和控制逻辑的芯片面积更少，每个着色器核心的延迟通常比CPU处理器遇到的要高得多。

&#x20;       假设一个网格被栅格化了，两千个像素需要处理碎片;一个像素着色程序将被调用2000次。假设只有一个着色器处理器，世界上最弱的GPU。它开始为2000的第一个片段执行着色程序。着色处理器对寄存器中的值执行一些算术操作。注册是本地的和快速的访问，所以不会发生暂停。然后，着色器处理器进入一个指令，如纹理访问;例如，对于给定的表面位置，程序需要知道应用到网格上的图像的像素颜色。纹理是一个完全独立的资源，而不是像素程序本地内存的一部分，并且纹理访问可能会涉及一些内容。一次内存获取可能需要数百到数千个时钟周期，在此期间GPU处理器不做任何事情。此时，着色器处理器将暂停，等待纹理的颜色值返回。

&#x20;        为了让这个糟糕的GPU变得更好，我们需要为每个片段提供一些存储空间用于其本地寄存器。现在，shader处理器可以切换并执行另一个片段，2000中的第2个片段，而不是在获取纹理时停滞不前。这个切换非常快，除了注意哪个指令在第一个指令上执行之外，第一个或第二个片段中没有任何影响。现在执行第二个片段。与第一个相同，执行一些算术函数，然后再次遇到纹理获取。着色器核心现在切换到另一个片段，三号。最终，所有2000个片段都以这种方式处理。此时，着色器处理器返回到片段1。此时纹理颜色已经被获取，可以使用，所以着色程序可以继续执行。处理器以同样的方式继续执行，直到遇到另一条已知会导致执行暂停的指令，或者程序完成。一个单独的片段将花费比如果着色处理器关注它更长的时间来执行，但整体上片段的整体执行时间大大减少。

&#x20;           在这个架构中，通过切换到另一个片段让GPU保持忙碌，可以隐藏延迟。GPU通过将指令执行逻辑与数据分离，将这种设计向前推进了一步。被称为单指令多数据(SIMD)，这种安排在固定数量的着色程序上以锁步的方式执行相同的命令。SIMD的优点是，与使用单独的逻辑和调度单元来运行每个程序相比，用于处理数据和切换的硅(和功率)要少得多。把我们的2000个片段例子转换成现代的GPU术语，每个片段的像素着色器调用被称为线程。这种类型的线程不像CPU线程。它包含了一点内存，用于给着色器输入值，以及着色器执行所需的任何寄存器空间。使用相同着色程序的线程被捆绑成组，NVIDIA称之为warps，AMD称之为wavefronts。warps/wavefronts被安排由一定数量的GPU着色器内核执行，从8到64，使用SIMD处理。每个线程都映射到一个SIMD通道。

&#x20;       假设我们有两千个线程要执行。NVIDIA的GPU上的warp包含32个线程。这就产生了2000/32 = 62.5条经纱，这意味着分配了63条warps，其中一条warps只被占用了一半。warps的执行类似于单一GPU处理器的例子。着色程序在所有32个处理器上执行。当遇到内存获取时，所有线程都同时遇到它，因为对所有线程执行相同的指令。fetch信号表明这个warp线程将停止，所有线程都在等待它们的(不同的)结果。而不是延迟。warp被替换为32个线程的不同warp，然后由32个内核执行。这种交换就像我们的单处理器系统一样快，因为当warp被交换时，每个线程内的数据都不会被接触。每个线程都有自己的寄存器，每个warp跟踪它正在执行的指令。 在一个新的warp中，warp只是将一组核心指向另一组要执行的线程，没有其他消耗。执行或切换warp，直到全部完成。如图2.1。

&#x20;       着色程序的结构是影响效率的一个重要特性。一个主要因素是每个线程的寄存器使用量。在我们的例子中，我们假设两千个线程可以同时驻留在GPU上。与每个线程关联的着色程序需要的寄存器越多，驻留在GPU中的线程就越少，因此warp也就越少。缺乏warp可能意味着延迟不能通过交换来缓解。常驻的warp被称为在飞行中in flight，这个数字被称为占用率。高占用率意味着有许多可处理的warp，因此空闲处理器的可能性较小。占用率低往往会导致性能不佳。内存获取的频率也会增加延迟。

&#x20;       另一个影响整体效率的因素是由if语句和循环引起的动态分支。假设在着色程序中遇到if语句。如果所有的线程都计算并使用同一个分支，那么warp就可以继续运行而不需要考虑其他分支。然而，如果一些线程，甚至是一个线程，采用了替代路径，那么warp必须执行两个分支，抛弃每个特定线程不需要的结果。这个问题被称为线程分歧thread divergence，在这种情况下，一些线程可能需要执行一个循环迭代或执行一个if路径，而在warp中其他线程不需要，这使得它们在这段时间内处于空闲状态。

&#x20;       所有GPU都实现了这些架构思想，导致系统受到严格的限制，但每瓦特的计算能力却是巨大的。了解这个系统是如何运行的，将有助于作为程序员的您更有效地利用它提供的功能。

![图2.1](.gitbook/assets/Snipaste\_2021-09-21\_09-25-13.png)

&#x20;       简化的着色器执行示例。一个三角形的片段，被一个线程调用。每条wrap包含四个线程，但实际上有32个线程。要执行的着色程序有5条指令。第一个wrap的四个GPU着色处理器的集合执行这些指令，直到在txr命令上检测到一个暂停条件，这需要时间来获取它需要的数据。第二个wrap被调度，着色程序的前三个指令被应用到它，直到再次检测到暂停条件。在第三次wrap被调度并停止后，执行被交换的第一个wrap并继续执行。如果此时它的txr命令的数据还没有返回，那么执行将真正停止，直到这些数据可用为止。每条wrap依次调度。

### 2.2 GPU管线概述 GPU Pipeline Overview

&#x20;        图2.2为GPU实现的渲染流水线，按照顺序依次为:    顶点着色器、曲面细分着色器、几何着色器、裁剪、屏幕映射、三角形设置和遍历、片段着色器、合并。这些阶段根据用户对其操作的控制程度用颜色编码。绿色阶段是完全可编程的。虚线表示可选阶段。黄色阶段是可配置的，但不能编程，例如，可以为合并阶段设置各种混合模式。蓝色阶段的功能是完全固定的,不可编程的。

![图2.2](<.gitbook/assets/Snipaste\_2021-09-21\_09-38-39 (1).png>)

&#x20;       GPU实现了第2章中描述的概念:  几何处理、光栅化和像素处理流水线阶段。它们被分为几个硬件阶段，具有不同程度的可配置性或可编程性。图3.2显示了根据可编程或可配置程度用颜色编码的各个阶段。注意，这些物理阶段的划分与第2章中介绍的功能阶段有所不同。

&#x20;       我们在这里描述的是GPU的逻辑模型，作为程序员的你可以通过API看到它。这个逻辑管道(物理模型)的实现取决于硬件供应商。通过向相邻的可编程阶段添加命令，可以在GPU上执行逻辑模型中具有固定功能的阶段。管线中的单个程序可以被分割成由单独的子单元执行的元素，也可以完全由单独的传递执行。逻辑模型可以帮助推断什么会影响性能，但它不应该被误解为GPU实际实现管道的方式。

&#x20;        顶点着色器是一个完全可编程的阶段，用于实现几何处理阶段。几何着色器是一个完全可编程的阶段，对图元(点，线，或三角形)的顶点进行操作。它可以用来执行每个图元的着色操作，销毁图元，或者创建新的图元。 曲面细分阶段和几何着色器都是可选的，并不是所有的GPU都支持它们，特别是在移动设备上。

&#x20;       裁剪、三角形设置和三角形遍历阶段由固定功能的硬件实现。屏幕映射受窗口和视口设置的影响，在内部形成一个简单的比例和重新定位。

&#x20;       片段着色器阶段是完全可编程的。虽然合并阶段不是可编程的，但它是高度可配置的，可以设置以执行各种各样的操作。它实现了合并功能阶段，负责修改颜色，z缓冲区，混合，模板和任何其他输出相关的缓冲区。像素着色器的执行和合并阶段构成了第2章中介绍的像素处理阶段的概念。

### 2.3 可编程着色器阶段 The Programmable Shader Stage

&#x20;       现代着色程序使用统一的着色器设计。这意味着顶点、像素、几何和曲面细分相关的着色器共享一个共同的编程模型。它们在内部具有相同的指令集体系结构(ISA)。实现这个模型的处理器被称为DirectX中的common-shader core，具有这种内核的GPU被称为具有统一的shader架构。这种架构背后的想法是，着色器可以用于多种角色，GPU可以根据需要分配这些角色。例如，一组由小三角形组成的网格比由两个三角形组成的大正方形需要更多的顶点着色器处理。拥有独立的顶点和像素着色器核池的GPU意味着保持所有核繁忙的理想工作分布是严格预定的。使用统一的着色器内核，GPU可以决定如何平衡这种负载。

&#x20;       着色程序使用类似c的着色语言，如DirectX的高级着色语言(HLSL)和OpenGL着色语言(GLSL)。DirectX的HLSL可以编译为虚拟机字节码，也称为中间语言(IL或dxie)，以提供硬件独立性。中间表示法也可以让着色程序离线编译和存储。该中间语言被驱动程序转换为特定GPU的ISA。控制台编程通常避免中间语言步骤，因为那时系统只有一个ISA。

&#x20;       基本的数据类型是32位单精度浮点标量和向量，尽管向量只是着色器代码的一部分，并且在上面概述的硬件中不支持。在现代gpu上，本地也支持32位整数和64位浮点数。浮点向量通常包含位置(xyzw)、法线、矩阵行、颜色(rgba)或纹理坐标(uvwq)等数据。整数最常用于表示计数器、索引或位掩码。还支持聚合数据类型，如结构、数组和矩阵。

&#x20;        一个draw call调用图形API来绘制一组图元，因此导致图形管道执行和运行它的着色器。每个可编程着色器阶段有两种类型的输入:uniform的输入，在整个绘制调用中保持不变的值(但可以在绘制调用之间改变)，和varying的输入，来自三角形顶点或光栅化的数据。例如，一个像素着色器可以提供光源的颜色作为一个uniform的值，并且三角形表面的位置每个像素都在变化。纹理是一种特殊的uniform输入，它曾经是应用于表面的彩色图像，但现在它可以被认为是任何大的数据数组。

&#x20;       底层虚拟机为不同类型的输入和输出提供了特殊的寄存器。uniforms可用的常数寄存器的数量要比用于varying输入或输出的寄存器多得多。这是因为varying的输入和输出需要分别存储在每个顶点或像素上。所以需要多少是有限制的。uniforms输入存储一次，并在draw call中的所有顶点或像素中重用。虚拟机还有通用的临时寄存器，用于临时存储空间。 所有类型的寄存器都可以在临时寄存器中使用整数值进行数组索引。 着色虚拟机的输入和输出如图2.3所示。

![图2.3](.gitbook/assets/Snipaste\_2021-09-21\_15-14-39.png)

&#x20;        图形计算中常见的操作可以在现代GPU上高效地执行。着色语言通过操作符\*和+暴露了这些最常见的操作(如加法和乘法)。其余的通过内在函数暴露，例如，atan()， sqrt()， log()和许多其他的，为GPU优化。函数也存在于更复杂的运算，如向量的标准化和反射，叉积，矩阵转置和行列式计算。

&#x20;       术语流控制指的是使用分支指令来更改代码执行流。与流控制相关的指令用于实现高级语言构造，如if和case语句，以及各种类型的循环。着色器支持两种类型的流控制。静态流控制分支基于uniform输入的值。这意味着代码流在draw call中是不变的。静态流控制的主要好处是允许相同的着色器在不同的情况下使用(例如，不同数量的灯光)。没有线程分歧，因为所有调用都采用相同的代码路径。动态流控制是基于不同的输入值，这意味着每个片段可以以不同的方式执行代码。这比静态流控制更强大，但会降低性能，特别是当代码流在着色器调用之间变化不稳定时。

### 2.4 可编程着色的进化史 The Evolution of Programmable Shading

&#x20;       可编程着色框架的想法可以追溯到1984年Cook 的shade trees。一个简单的着色器及其对应的shade trees如图2.4所示。RenderMan着色语言是在20世纪80年代后期从这个想法发展而来的。它今天仍然被用于电影制作渲染，以及其他不断发展的规范，如开放着色语言(OSL)项目\[608]。1996年10月1日，3dfx Interactive首次成功地推出了消费者级图形硬件。图3.5是今年的时间表。他们的Voodoo显卡能够渲染游戏《雷神之锤》的高质量和性能，使其迅速被采用。这个硬件实现了一个固定功能的管道。在GPU原生支持可编程着色器之前，通过多个渲染通道实现可编程着色操作的尝试很多。《雷神之锤3:竞技场》的脚本语言最先被广泛使用。

![图2.4](.gitbook/assets/Snipaste\_2021-09-21\_15-28-41.png)

&#x20;         一个简单的铜着色器（Cook的 shade trees）和其对应的着色语言代码。

### 2.5 顶点着色器 The Vertex Shader

&#x20;        顶点着色器是如图2.2所示的函数管道中的第一阶段。虽然这是直接由程序员控制的第一阶段，但值得注意的是，在此阶段之前发生了一些数据操作。在DirectX调用的输入汇编器中，几个数据流可以编织在一起，形成沿管道发送的顶点和图元集合。例如，一个对象可以由一个位置数组和一个颜色数组表示。输入汇编程序将通过创建具有位置和颜色的顶点来创建对象的三角形(或线或点)。第二个对象可以使用相同的位置数组(以及不同的模型转换矩阵)和不同的颜色数组来表示它。在输入汇编程序中也支持执行实例化。这允许一个对象用每个实例的一些变化的数据绘制多次，所有这些都只用一个绘制调用。

&#x20;       三角形网格由一组顶点表示，每个顶点都与模型表面上的特定位置相关联。除了位置之外，每个顶点还有其他可选属性，比如颜色或纹理坐标。表面法线也定义在网格顶点，这似乎是一个奇怪的选择。数学上，每个三角形都有一个明确定义的表面法线，它似乎更有意义使用三角形的法线直接进行着色。然而，在渲染时，三角形网格通常被用来表示一个底层曲面，顶点法线被用来表示曲面的方向，而不是三角形网格本身的方向。图2.7显示了两个代表曲面的三角形网格的侧视图，一个平滑，一个有尖锐的折痕。

![图2.7](.gitbook/assets/Snipaste\_2021-09-21\_15-35-09.png)

&#x20;       三角形网格的侧视图(黑色，顶点法线)表示曲面 (红色)。在左边平滑的顶点法线被用来表示平滑的表面。在右边，中间顶点被复制，并给出两条法线，表示一条折痕。

&#x20;       顶点着色器是处理三角形网格的第一阶段。顶点着色器无法创建三角形。顾名思义，它只处理传入的顶点。顶点着色器提供了一种方法修改、创建或忽略与每个三角形顶点相关的值，如其颜色、法线、纹理坐标和位置。通常顶点着色程序将顶点从模型空间转换到齐次裁剪空间。顶点着色器必须始终输出这个位置。

&#x20;       顶点着色器与前面描述的标准着色器非常相似。每个传入的顶点都由顶点着色程序处理，然后输出一些值，这些值被插入到三角形或直线上。顶点着色器既不能创建也不能销毁顶点，一个顶点生成的结果不能传递到另一个顶点。因为每个顶点都是独立处理的，所以GPU上的任意数量的着色器处理器都可以并行应用于传入的顶点流。

&#x20;       输入装配通常是在执行顶点着色器之前出现的一个过程。在这个例子中，物理模型经常与逻辑模型不同。物理上，获取数据来创建顶点可能会发生在顶点着色器中，驱动程序会悄悄地为每个着色器添加适当的指令，而程序员是看不见的。

&#x20;        后续章节解释了几个顶点着色器的效果，比如用于动画关节的顶点混合和轮廓渲染。顶点着色器的其他用途包括:

* 对象生成，只创建一个网格，并让它被顶点着色器变形。
* 使用皮肤和变形技术表现人物的身体和脸的动画。
* 过程化的变形，如旗帜、布料或水的移动。
* 粒子创建，通过发送退化(无区域)网格到管道下，并根据需要给这些网格一个区域。
* 镜头失真、热雾、水波纹、页面卷曲和其他效果，通过使用整个framebuffer的内容作为纹理在屏幕对齐的网格上进行程序变形。
* 使用顶点纹理获取来应用地形高度域。

&#x20;       使用顶点着色器完成的一些变形如图2.8所示。

![图3.8](.gitbook/assets/Snipaste\_2021-09-21\_15-46-04.png)

&#x20;        图3.8左边是一个普通的茶壶。一个简单的裁剪操作执行顶点着色程序产生中间的图像。在右边，一个噪声函数创建了一个扭曲模型的场。

&#x20;       顶点着色器的输出可以用几种不同的方式来使用。通常的路径是每个实例的图元，例如，三角形，然后被生成和光栅化，产生的单个像素片段被发送到像素着色程序继续处理。在一些GPU上，数据也可以发送到曲面细分阶段或几何着色器或存储在内存中。下面几节将讨论这些可选阶段。

### 2.6 曲面细分阶段 The Tessellation Stage

&#x20;       曲面细分阶段允许我们渲染曲面。GPU的任务是将每个表面描述转换成一组具有代表性的三角形。这个阶段是一个可选的GPU特性，它首先在DirectX 11中可用(并且是必需的)。OpenGL 4.0和OpenGL ES 3.2也支持它。使用曲面细分阶段有几个优点：曲面的描述往往比提供相应的三角形本身更紧凑。除了节省内存，这一特性还可以避免CPU和GPU之间的总线（数据传输）成为动画角色或每帧形状都在变化的对象的瓶颈。通过为给定的视图生成适当数量的三角形，可以有效地渲染表面。例如，如果一个球离相机很远，那么只需要几个三角形。近距离时，它可能用数千个三角形表现得最好。这种控制细节级别的能力也允许应用程序控制其性能，例如，在较弱的GPU上的使用较低质量的网格来维持帧率。通常由平面表示的模型可以转换为三角形细网格，然后根据需要进行弯曲，或者可以对模型进行细分，以减少昂贵的着色计算。曲面细分阶段通常由三个部分组成。在DirectX的中，这些是外壳着色器hull shader，曲面细分tessellator ，和域着色器domain shader。在OpenGL中，外壳着色器叫做曲面细分控制着色器，域着色器叫做曲面细分评估着色器，OpenGL的叫法描述性更强，虽然有点冗长。固定函数tesselator在OpenGL中被称为曲面细分生成器，正如我们将看到的，这确实是它所做的。

&#x20;       外壳着色器的输入是一个特殊的patch图元，该patch图元由多几个控制点定义细分曲面、贝塞尔bezier patch或其他类型的曲线元素。外壳着色器有两个功能，首先，它告诉曲面细分器应该生成多少个三角形，以及在地方生成。其次，它处理每个传入的控制点。此外，可选的，外壳着色器可以修改传入patch细节，根据需要添加或删除控制点。外壳着色器输出它的控制点集，到曲面细分生成器器和域着色器。参见图2.9。

![图2.9](.gitbook/assets/Snipaste\_2021-09-22\_17-09-15.png)

&#x20;       曲面细分阶段，外壳着色器采用了一个由控制点定义的patch。它将细分因子(TFs)和类型发送给曲面细分生成器。控制点集由外壳着色器根据需要进行转换并发送到域着色器，连同TF和相关的常量patch。曲面细分生成器创建顶点集及其重心坐标，并传递给域着色器处理，产生三角形网格(控制点显示为参考)。

&#x20;       曲面细分生成器是管道中的一个固定功能阶段，只与曲面细分着色器一起使用。它的任务是为域着色器添加几个新的顶点来处理。外壳着色器向曲面细分生成器发送关于需要哪种类型的细分表面的信息:三角形、四边形或等值线。等值线是一组线条，有时用于头发渲染。外壳着色器发送的其他重要值是曲面细分因子(OpenGL中的曲面细分级别)。这些有两种类型:内边缘和外边缘。这两个内部因素决定了多少曲面细分发生在三角形或四边形内部。外部因素决定每条外部边被分割的程度。图2.10显示了一个增加曲面细分因子的例子。通过允许单独的控制，我们可以让相邻曲面的边缘在曲面细分中匹配，而不管内部是如何曲面细分的。匹配的边缘避免了裂缝或其他阴影伪影。顶点被赋以重心坐标，这些值指定了所需曲面上每个点的相对位置。

![图2.10](.gitbook/assets/Snipaste\_2021-09-22\_19-17-15.png)

&#x20;         图2.10展示了改变曲面细分因子的影响。犹他州的茶壶由32块patch组成。内、外曲面细分因子从左到右分别为1、2、4、8。

&#x20;        外壳着色器总是输出一个patch（一组控制点位置）。但是，它可以通过向曲面细分生成器发送0或更小的外部曲面细分级别(或非数字，NaN)来表示要丢弃patch。否则，曲面细分生成器生成一个网格并将其发送到域着色器。曲面的控制点来自于外壳着色器，用于每次调用域着色器来计算每个顶点的输出值。域着色器有一个类似于顶点着色器的数据流模式，每个来自曲面细分生成器的输入顶点都被处理并生成相应的输出顶点。然后形成的三角形沿着管道传递下去。

&#x20;       外壳着色器一般很少会修改收到的patch。这个着色器也可以使用patch的估算距离或屏幕大小来动态计算细分因子，如地形渲染。另外，外壳着色器可以简单地传递应用程序计算和提供的所有patch的一组固定值。细分器执行一个复杂但功能固定的过程，生成顶点，给出它们的位置，并指定它们形成的三角形或直线。为了提高计算效率，数据放大步骤在着色器之外执行\[530]。域着色器获取每个点生成的重心坐标，并在patch的评估方程中使用这些坐标来生成位置、法线、纹理坐标和其他所需的顶点信息。如图2.11所示。

![图2.11](.gitbook/assets/Snipaste\_2021-09-26\_19-23-04.png)

&#x20;       左边是由6000个三角形组成的网格。在右侧，每个三角形使用PN三角形细分进行镶嵌和移位。

### 2.7 几何着色器 The Geometry Shader

&#x20;       几何着色器可以将图元转换成其他图元，这是曲面细分阶段做不到的。例如，一个三角形网格可以通过每个三角形创建线边来转换成线框视图。另外，这些线也可以用面向观众的四边形代替，这样就可以制作出边缘较厚的线框图。几何着色器在2006年末的DirectX 10发布时被添加到硬件加速的图形管道中。它位于管道中的曲面细分着色器之后，它的使用是可选的。虽然是Shader Model 4.0的必要部分，但在早期的Shader模型中没有使用。OpenGL 3.2和OpenGL ES 3.2也支持这种类型的着色器。

&#x20;       几何着色器的输入是一个单一的对象及其相关的顶点。物体通常由条状、线段或简单点上的三角形组成。几何着色器可以定义和处理扩展图元。特别地，三角形外的三个额外顶点可以被传递进来，折线上的两个相邻顶点也可以被使用。参见图2.12。使用DirectX 11和Shader Model 5.0，你可以通过更复杂的patch，多达32个控制点。也就是说，曲面细分阶段对生成patch更有效\[175]。



![图2.12](.gitbook/assets/Snipaste\_2021-09-26\_19-28-37.png)

&#x20;       几何着色程序的几何着色输入是一些单一类型:点，线段，三角形。最右边的两个图元包括与直线和三角形对象相邻的顶点。也可以使用更复杂的patch类型。

&#x20;       几何着色器处理图元并输出零个或多个顶点，这些顶点被视为点、折线或三角形条。注意，任何输出都不能由几何着色器生成，即几何着色器只能输出点、折线和三角形条。通过这种方式，可以通过编辑顶点、添加新原语和删除其他原语来选择性地修改网格。

&#x20;       几何着色器旨在修改传入数据或制作有限数量的副本。 例如，一种用途是生成六个转换后的数据副本以同时渲染立方体贴图的六个面。 它还可以用于高效地创建级联阴影贴图以生成高质量的阴影。利用几何着色器的其他算法包括从点数据创建可变大小的粒子、沿着轮廓挤出鳍以进行毛发渲染，以及为阴影算法寻找对象边缘 . 有关更多示例，请参见图 2.13。

![图2.13](.gitbook/assets/Snipaste\_2021-10-04\_09-13-21.png)

&#x20;      几何着色器 (GS) 的一些用途。 在左侧，使用 GS 实现元球的等值面曲面细分。 在中间，使用 GS 完成线段的分形细分并输出，并且由 GS 生成用于显示闪电的广告牌。 在右侧，布料模拟是通过使用带有流输出的顶点和几何着色器来执行的。

&#x20;        DirectX 11 添加了几何着色器使用实例化的能力，其中几何着色器可以在任何给定的图元上运行一定次数。在 OpenGL 4.0 中，这是用调用计数指定的。 几何着色器还可以输出多达四个流。 一个流可以向下发送到渲染管道以进行进一步处理。 所有这些流都可以选择发送到流输出渲染目标。

&#x20;       几何着色器保证从图元中输出与输入顺序相同的结果。这影响性能，因为如果几个着色器内核并行运行，结果必须保存和排序。这和其他因素不利于几何着色器在一个单一的调用中复制或创建大量的几何。

&#x20;       在进行绘制调用后，管道中只有三个地方是在 GPU 上工作：光栅化、曲面细分阶段和几何着色器。其中，当考虑到资源和内存需求时，几何着色器的行为是最不可预测的，因为它是完全可编程的。 在实践中，几何着色器通常用处不大，因为它不能很好地映射到 GPU 的优势。 在某些移动设备上，它是在软件中实现的，因此在那里积极不鼓励使用。

#### 2.7.1 流输出 Stream Output

&#x20;       GPU管道的标准用法是通过顶点着色器发送数据，然后栅格化生成的三角形，并在像素着色器中处理这些数据。过去，数据总是通过管道传递，中间结果无法访问。在Shader Model 4.0中引入了流输出的思想。 顶点被顶点着色器处理后(和，可选的，曲面细分和几何着色器)，除了被发送到光栅化阶段，还可以在流中输出，例如，一个有序数组。以这种方式处理的数据可以通过管道发回，从而允许迭代加工。 这种类型的操作可用于模拟流动的水或其他粒子效应，它也可用于为模型蒙皮和然后让这些顶点可以重复使用。

&#x20;       流输出仅以浮点数的形式返回数据，因此它可能有显著的内存消耗。流输出在图元上工作，而不是直接在顶点上工作。如果网格沿着管道发送，每个三角形都会生成自己的一组输出顶点。在原始网格中共享的任何顶点都将丢失。出于这个原因，更典型的用法是将顶点作为点集图元通过管道发送。在OpenGL中，流输出阶段被称为转换反馈，因为它的主要用途是转换顶点并返回它们以供进一步处理。

### &#x20;2.8 像素着色器 The Pixel Shader

&#x20;       在顶点、曲面细分和几何着色器执行它们的操作后，图元被裁剪并设置为光栅化。 管道的这一部分在其处理步骤中是相对固定的，也就是说，不是可编程的，但某种程度上是可配置的。每个三角形都被遍历以确定它覆盖了哪些像素。光栅化器还可以粗略计算三角形覆盖每个像素的单位面积。三角形部分或完全重叠像素的部分称为片段。

&#x20;       三角形顶点上的值，包括z缓冲区中使用的z值，将为每个像素在三角形的表面上进行插值。这些值被传递给像素着色器，然后处理片段。在OpenGL中，像素着色器被称为片段着色器，这可能是一个更好的名字。为了一致性，我们在本书中使用“像素着色器”。沿着管道发送的点和线图元也会为所覆盖的像素创建片段。

&#x20;       在三角形上执行的插值类型由像素着色程序指定。通常情况下，我们使用透视校正插值，这样当物体后退时，像素表面位置之间的世界空间距离就会增加。一个例子是渲染延伸到地平线的铁轨。铁轨越远的地方，枕木间距越近，因为每一个接近视界的连续像素所走过的距离就越远。其他插值选项也可用，如屏幕空间插值，其中不考虑透视投影。DirectX 11进一步控制了插值的时间和方式。&#x20;

&#x20;       在编程方面，顶点着色程序的输出，通过插入三角形(或线)，有效地成为像素着色程序的输入。随着 GPU已经进化了，其他的输入也暴露了。例如，在shader Model 3.0或更高版本中，片段的屏幕位置对像素着色器可用。三角形的哪边是可见的是一个输入标志。这个知识对于渲染每个三角形的正面和背面的不同材质是很重要的。

&#x20;       有了输入，像素着色器通常会计算并输出片段的颜色。它也可能产生一个不透明度值和可选地修改它的z-depth。在合并期间，这些值用于修改存储在像素上的内容。光栅化阶段产生的深度值也可以通过像素着色器进行修改。模板缓冲区值通常是不可修改的，但它会被传递到合并阶段。DirectX 11.3允许着色器改变这个值。在SM 4.0中，雾计算和alpha测试等操作已经从合并操作变成了像素着色器计算。

&#x20;       像素着色器还具有丢弃传入片段的独特能力，即不生成输出。图2.14显示了如何使用片段丢弃的一个示例。裁剪平面功能曾经是固定函数管道中的一个可配置元素，后来在顶点着色器中指定。随着片段丢弃可用，这个功能可以在像素着色器中以任何想要的方式实现，例如决定剪裁体积是否应该被“与”或“或”在一起。

![图2.14](.gitbook/assets/Snipaste\_2021-10-04\_10-27-01.png)

&#x20;       用户定义的裁剪平面。 在左侧，单个水平裁剪平面对对象进行切片。 在中间，嵌套的球体被三个平面裁剪。 在右侧，球体的表面仅在它们位于所有三个剪裁平面之外时才会被剪裁。

&#x20;       最初，像素着色器只能输出到合并阶段，以便最终显示。随着时间的推移，像素着色器可以执行的指令数量已经显著增加。这种增加产生了多渲染目标(MRT)的想法。不是将像素着色器程序的结果仅发送到颜色和 z 缓冲区，而是可以为每个片段生成多组值并保存到不同的缓冲区，每个缓冲区称为渲染目标。渲染目标通常具有相同的x和y维度;有些api允许不同的大小，但是渲染区域是最小的。有些架构要求每个渲染目标具有相同的位深，甚至可能具有相同的数据格式。根据GPU，可用的渲染目标数量是4或8个。

&#x20;        即使有这些限制，MRT 功能仍然是更有效地执行渲染算法的有力帮助。 单个渲染通道可以在一个目标中生成彩色图像，在另一个目标中生成对象标识符，在第三个中生成世界空间距离。 这种能力还产生了一种不同类型的渲染管道，称为延迟着色，其中可见性和着色在单独的通道中完成。 第一遍在每个像素处存储有关对象位置和材质的数据。 连续的通道可以有效地应用照明和其他效果。 此类渲染方法在第 20.1 节中描述。

&#x20;       像素着色器的限制是，它通常只能在交付给它的片段位置写入渲染目标，而不能从邻近的像素读取当前结果。也就是说，当一个像素着色程序执行时，它不能将其输出直接发送到邻近的像素，也不能访问其他最近的更改。因此，它计算的结果只影响它自己的像素。然而，这种限制并不像听起来那么严重。在一个通道中创建的输出图像可以在以后的通道中由像素着色器访问其任何数据。相邻像素可以使用图像处理技术进行处理，如第12.1节所述。

&#x20;        像素着色器无法知道或影响相邻像素结果的规则也有例外。一个是在梯度或导数信息的计算过程中，像素着色器可以立即访问相邻片段的信息(尽管是间接的)。像素着色器提供了沿着x和y屏幕轴每个像素的任何插值值变化的数量。这些值对于各种计算和纹理寻址都很有用。这些梯度对于纹理过滤(章节6.2.2)这样的操作尤其重要，在这些操作中，我们可以知道图像覆盖了多少像素。所有现代的GPU都是通过以2 × 2为一组(称为quad)处理片段来实现这一功能的。当像素着色器请求一个梯度值时，将返回相邻片段之间的差异。参见图2.15。统一核心具有访问相邻数据的能力——保持在同一wrap上的不同线程——因此可以计算用于像素着色器的梯度。这种实现的一个结果是梯度信息不能在受动态流控制影响的着色部分访问，例如，if语句或具有可变迭代次数的循环。一组中的所有片段必须使用相同的指令集进行处理，以便所有四个像素的结果对计算梯度都有意义。这是即使在离线渲染系统中也存在的一个基本限制。

![图2.15](.gitbook/assets/Snipaste\_2021-10-04\_14-52-14.png)

&#x20;       在左侧，一个三角形被光栅化为四边形，一组 2 × 2 像素。 用黑点标记的像素的梯度计算显示在右侧。 对于四边形中的四个像素位置中的每一个，都显示了 v 的值。 注意三个像素是没有被三角形覆盖的，但它们仍然由 GPU 处理，以便可以找到梯度。 x 和 y 屏幕方向的梯度是通过使用其两个四边形邻居为左下像素计算的。

&#x20;       DirectX11引入了一种缓冲区类型，允许对任何位置的写访问，即无序访问视图(UAV)。最初仅用于像素和计算着色器，在DirectX 11.1中UAV 扩展到所有着色器。OpenGL 4.3将其称为着色器存储缓冲区对象(SSBO)。这两个名字都有自己的描述性。像素着色器以任意顺序并行运行，并且存储缓冲区在它们之间共享。

&#x20;       通常需要一些机制来避免数据竞争条件(也称为数据危险)，在这种情况下，两个着色程序可能会竞争影响相同的值，可能导致任意的结果。例如，如果对一个像素着色器的两次调用试图在大约相同的时间添加相同的检索值，就可能发生错误。两者都将检索原始值，都将在本地修改它，但无论最后哪个调用写入其结果，都会删除另一个调用的贡献，只会发生一个添加。GPU通过使用着色器可以访问的专用原子单位来避免这个问题\[530]。然而，原子意味着一些着色器可能会暂停，因为他们等待访问内存位置进行读/修改/写另一个着色器。

&#x20;       虽然原子可以避免数据危险，但许多算法需要特定的执行顺序。例如，您可能想在用红色透明三角形覆盖它之前绘制一个更远的透明蓝色三角形，将红色混合在蓝色之上。像素有可能有两个像素的像素着色器调用,每个三角形,一个执行这样的红色三角形材质完成之前蓝色的年代。在标准的管道中,片段的结果排序在合并阶段之前被处理。在directx11.3中引入了光栅化顺序视图(ROV)来强制执行顺序。这些就像UAV;它们可以被着色器以同样的方式读取和写入。关键的区别在于，ROV可以保证数据以正确的顺序被访问。这大大增加了这些着色器可访问缓冲区的用处。例如，ROV使像素着色器可以编写自己的混合方法，因为它可以直接访问和写入ROV中的任何位置，因此不需要合并阶段。代价是，如果检测到无序访问，像素着色器调用可能会暂停，直到处理之前绘制的三角形。

### 2.9 合并阶段 The Merging Stage

&#x20;       合并阶段是单个片段(在像素着色器中生成)的深度和颜色与framebuffer合并的阶段。DirectX将这个阶段称为输出合并;OpenGL将其称为按样本操作。在大多数传统的管道图(包括我们自己的)中，这个阶段是模板缓冲区和z缓冲区操作发生的地方。如果片段是可见的，在这个阶段发生的另一个操作是颜色混合。对于不透明的表面，不涉及真正的混合，因为片段的颜色只是简单地替换先前存储的颜色。片段和存储颜色的实际混合通常用于透明度和合成操作(章节5.5)。

&#x20;       想象一个由光栅化生成的片段通过像素着色器运行，然后当zbuffer应用时发现一些先前渲染的片段被隐藏。所有在像素着色器中完成的处理都是不必要的。为了避免这种浪费，许多GPU在像素着色器执行之前执行一些合并测试。片段的z深度(以及其他任何正在使用的东西，如模板缓冲或裁剪)用于测试可见性。如果隐藏，片段将被剔除。这种功能被称为early-z。像素着色器有能力改变片段的z深度或完全丢弃碎片。如果发现在像素着色程序中存在任何一种类型的操作，early-z通常不能被使用，并被关闭，这通常会降低管道的效率。DirectX 11和OpenGL 4.2允许像素着色器强制启动early-z测试，尽管有一些限制。有关early-z和其他z-buffer优化的更多信息，请参阅第23.7节。有效地使用early-z会对性能有很大的影响，这将在第18.4.5节中详细讨论。

&#x20;       合并阶段占据了固定功能阶段之间的中间地带，如三角形设置，和完全可编程的着色阶段。虽然它不是可编程的，但它的操作是高度可配置的。特别是颜色混合，可以进行大量不同的操作。最常见的是涉及颜色和alpha值的乘法、加法和减法的组合，但也可以进行其他操作，如最小和最大值，以及按位逻辑操作。DirectX 10增加了将像素着色器中的两种颜色与framebuffer颜色混合的功能。这个功能被称为双源颜色混合，不能与多个渲染目标一起使用。除此之外，MRT支持混合，DirectX 10.1引入了在每个单独的缓冲区上执行不同的混合操作的能力。

&#x20;       正如上一节末尾所提到的，DirectX 11.3提供了一种通过ROV使混合可编程的方法，尽管在性能上付出了代价。ROV和合并阶段都保证了绘制顺序，也就是输出不变性。不管像素着色器结果生成的顺序是什么，API要求结果按照输入的顺序进行排序并发送到合并阶段。

### 2.10 计算着色器 The Compute Shader

&#x20;        GPU不仅可以用于实现传统的图形流水线。从计算股票期权的估值到为深度学习训练神经网络，在各个领域都有许多非图形化的应用。以这种方式使用硬件被称为GPU计算。像CUDA和OpenCL这样的平台被用来控制GPU作为一个巨大的并行处理器，不需要或访问图形特定的功能。这些框架通常使用C或C++等带有扩展的语言，以及为GPU制作的库。&#x20;

&#x20;       在DirectX 11中引入的，计算着色器是GPU计算的一种形式，因为它是一个不锁定在图形管道中的位置的着色器。它与呈现过程紧密相关，因为它是由图形API调用的。它与顶点、像素和其他着色器一起使用。它利用了与管道中使用的相同的统一着色处理器池。它是一个像其他着色器一样的着色器，因为它有一些输入数据集，可以访问缓冲区(如纹理)的输入和输出。warps和线程在计算着色器中更明显。例如，每次调用都会获得一个可以访问的线程索引。还有一个线程组的概念，在DirectX 11中由1到1024个线程组成。这些线程组由x-， y-和z-坐标指定，主要是为了在着色器代码中简单使用。每个线程组都有少量在线程之间共享的内存。在DirectX 11中，这相当于32 kB。计算着色器是由线程组执行的，因此线程组中的所有线程都保证并发运行。

&#x20;       计算着色器的一个重要优势是它们可以访问在GPU上生成的数据。将数据从GPU发送到CPU会有一定的延迟，因此如果处理和结果能够保留在GPU上，则可以提高性能。后期处理，即以某种方式修改已渲染的图像，是计算着色器的常用用途。共享内存意味着来自采样图像像素的中间结果可以与相邻线程共享。例如，使用计算着色器来确定图像的分布或平均亮度，其运行速度是在像素着色器上执行此操作的两倍。

&#x20;      计算着色器也适用于粒子系统、网格处理，如面部动画、剔除、图像滤波、提高深度精度、阴影、景深，以及任何其他可以使用GPU处理器的任务。Wihlidal讨论了计算着色器如何比曲面细分外壳着色器更有效。其他用途见图3.16。

![图3.16](.gitbook/assets/Snipaste\_2021-10-04\_15-21-29.png)

&#x20;       计算着色器的例子。在左边，一个计算着色器用来模拟受风影响的头发，头发本身使用曲面细分阶段渲染。在中间，一个计算着色器执行快速模糊操作。右边是模拟的海浪。

&#x20;       这就是我们对渲染管道GPU实现的回顾。有许多方法可以使用和组合GPU功能来执行各种与渲染相关的过程。为利用这些能力而调整的相关理论和算法是本书的中心主题。我们的重点现在转移到变换和阴影。&#x20;





&#x20;       &#x20;
