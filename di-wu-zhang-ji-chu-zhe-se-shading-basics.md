# 第五章 · 基础着色 Shading Basics

&#x20;       当您渲染 3D 对象的图像时，模型不仅应该具有适当的几何形状，还应该具有所需的视觉外观。 根据应用的不同，这可以从照片写实（与真实物体的照片几乎相同的外观）到各种类型的风格化外观。 有关两者的示例，请参见图 5.1。 本章将讨论同样适用于逼真渲染和风格化渲染的着色的那些方面。 第 15 章专门介绍风格化渲染，本书的重要部分（第 9 章到第 14 章）重点介绍常用于照片级渲染的基于物理的方法。

![图 5.1](.gitbook/assets/Snipaste\_2021-10-06\_19-18-56.png)

&#x20;       顶部图像来自使用虚幻引擎渲染的逼真风景场景。 底部图像来自 Campo Santo 的游戏 Firewatch，该游戏采用说明性艺术风格设计。 与大多数着色模型一样，此示例受相对于视图和光照方向的表面方向的影响。 出于着色目的，这些方向通常表示为归一化（单位长度）向量，如图 5.3 所示。 现在我们已经定义了着色模型的所有输入，我们可以看看模型本身的数学定义：

![](.gitbook/assets/Snipaste\_2021-10-06\_19-20-42.png)

![图 5.3 ](.gitbook/assets/Snipaste\_2021-10-06\_19-21-06.png)

&#x20;         示例着色模型（以及大多数其他模型）的单位长度向量输入：表面法线 n、视图向量 v 和光方向 l。

## 5.1 着色模型 Shading Models&#x20;

&#x20;       确定渲染对象的外观的第一步是选择一个着色模型，以描述对象的颜色应该如何根据表面方向、视图方向和照明等因素变化。

&#x20;       例如，我们将使用 Gooch 着色模型 \[561] 的变体。 这是非真实感渲染的一种形式，第 15 章的主题。 Gooch 着色模型旨在提高技术插图中细节的易读性。

&#x20;        Gooch 着色背后的基本思想是将表面法线与光的位置进行比较。 如果法线指向光线，则使用较暖的色调为表面着色； 如果它指向远处，则使用较冷的音调。 之间的角度在这些色调之间进行插值，这些色调基于用户提供的表面颜色。 在这个例子中，我们 为模型添加风格化的“高光”效果，使表面具有闪亮的外观。 图 5.2 显示了正在运行的着色模型。

&#x20;       着色模型通常具有用于控制外观变化的属性。 设置这些属性的值是确定对象外观的下一步。 我们的示例模型只有一个属性，即表面颜色，如图 5.2 的底部图像所示。

![图 5.2](.gitbook/assets/Snipaste\_2021-10-06\_19-17-33.png)

&#x20;        结合 Gooch 着色和高光效果的风格化着色模型。 上图显示了一个具有中性表面颜色的复杂对象。 下图显示了具有各种不同表面颜色的球体。&#x20;

&#x20;        在这个等式中，我们使用了以下中间计算：

![](.gitbook/assets/Snipaste\_2021-10-06\_19-26-07.png)

&#x20;       此定义中的几个数学表达式也经常出现在其他着色模型中。 钳位操作，通常钳位为 0 或钳位在 0 和 1 之间，在着色中很常见。 在这里，我们使用第 1.2 节中介绍的 x+ 表示法，作为用于计算高光混合因子 s 的 0 和 1 之间的钳位。 点积运算符出现 3 次，每次出现在两个单位长度向量之间； 这是一种极其常见的模式。 两个向量的点积是它们的长度和它们之间夹角的余弦的乘积。 因此，两个单位长度向量的点积就是余弦，这是衡量两个向量彼此对齐程度的有用度量。 简单的 由余弦组成的函数通常是解释着色模型中两个方向（例如光方向和表面法线）之间关系的最令人满意和最准确的数学表达式。

&#x20;        另一种常见的着色操作是基于 0 和 1 之间的标量值在两种颜色之间进行线性插值。该操作采用 tca + (1 − t)cb 的形式，当 t 的值在 1 和 0 之间移动时在 ca 和 cb 之间进行插值 ， 分别。 这种模式在这个着色模型中出现了两次，第一次是在 cwarm 和 ccool 之间进行插值，第二次是在之前的插值结果和 chighlight 之间进行插值。 线性插值经常出现在着色器中，以至于在我们见过的每种着色语言中，它都是一个内置函数，称为 lerp 或 mix。

&#x20;      “r = 2 (n · l)n - l”行计算反射光矢量，反射 l 大约 n。 虽然不像前两个操作那么常见，但对于大多数着色语言也有内置的反射功能来说，这已经足够常见了。

&#x20;       通过以不同方式将此类操作与各种数学表达式和着色参数相结合，可以为种类繁多的风格化和逼真的外观定义着色模型。

## 5.2 光源 Light Sources

&#x20;       光照对我们示例着色模型的影响非常简单； 它为着色提供了一个主导方向。 当然，现实世界中的照明可能非常复杂。 可以有多个光源，每个光源都有自己的大小、形状、颜色和强度；间接照明增加了更多的变化。 正如我们将在第 9 章中看到的，基于物理的、逼真的着色模型需要考虑所有这些参数。

&#x20;       相比之下，非写实stylized的着色模型可能会以多种不同的方式使用照明，具体取决于应用程序的需求和视觉风格。 一些高度非写实的模型可能根本没有照明概念，或者（如我们的 Gooch 着色示例）可能仅使用它来提供一些简单的方向性。

&#x20;       光照复杂性的下一步是使着色模型以二进制方式对光的存在或不存在做出反应。 用这种模型着色的表面在被照亮时将具有一种外观，而在不受光影响时具有不同的外观。 这暗示了区分这两种情况的一些标准：与光源的距离、阴影（将在第 7 章中讨论）、表面是否背对光源（即表面法线 n 与光矢量之间的夹角） l 大于 90°），或这些因素的某种组合。

&#x20;       从光的二元存在或不存在到光强度的连续尺度，这是一小步。 这可以表示为不存在和完全存在之间的简单插值，这意味着强度的有界范围，可能是 0 到 1，或者表示为以其他方式影响阴影的无界数量。 后者的一个常见选项是将着色模型分解为点亮和未点亮的部分，光强度 klight 线性缩放点亮的部分：

![](.gitbook/assets/Snipaste\_2021-10-06\_20-31-44.png)

&#x20;      这很容易扩展到 RGB 光色clight,

![](.gitbook/assets/Snipaste\_2021-10-07\_20-01-34.png)

&#x20;     和多个光源，

![](.gitbook/assets/Snipaste\_2021-10-08\_09-25-58.png)

&#x20;       unlit 部分 funlit(n, v) 对应于将光视为二进制的着色模型的“不受光影响时的外观”。 它可以有多种形式，具体取决于所需的视觉风格和应用程序的需要。 例如，funlit() = (0, 0, 0) 将使任何不受光源影响的表面变为纯黑色。 或者，未点亮的部分可以为未点亮的物体表达某种形式的风格化外观，类似于 Gooch 模型的冷色表面远离光线。 通常，着色模型的这部分表示某种形式的照明，这些照明不是直接来自明确放置的光源，例如来自天空的光或从周围物体反射的光。 这些其他形式的照明将在第 10 章和第 11 章中讨论。

&#x20;       我们之前提到，如果光的方向 l 与表面法线 n 的夹角超过 90°，则光源不会影响表面点，实际上来自表面下方。 这可以被认为是光的方向（相对于表面）对着色的影响的一种特殊情况。 尽管基于物理，但这种关系可以从简单的几何原理推导出来，并且对于许多类型的非基于物理的风格化着色模型也很有用。

&#x20;        光在表面上的效果可以可视化为一组光线，照射到表面的光线密度与用于表面着色目的的光强度intensity 相对应。 参见图 5.4，它显示了一个被照亮的表面的横截面。 沿着该横截面撞击表面的光线之间的间距与 l 和 n 之间的夹角的余弦成反比。 所以，入射到表面的光线的总密度与 l 和 n 之间夹角的余弦成正比，正如我们之前看到的，它等于这两个单位长度向量之间的点积。 下面我们看看为什么 可以方便地定义与光行进方向相反的光向量 l； 否则我们将不得不在执行点积之前否定它。

![图 5.4](.gitbook/assets/Snipaste\_2021-10-08\_09-36-45.png)

&#x20;       图 5.4上排的附图显示了表面上的光的横截面图。 在左侧，光线笔直地照射在表面上，在中心它们以一定角度照射表面，在右侧，我们看到使用矢量点积来计算角度余弦。 下图显示了与整个表面相关的横截面平面（包括光和视图矢量）。

&#x20;       更准确地说，光线密度density（以及光线对阴影的贡献）与点积为正时成正比。 负值对应于来自表面后面的光线，没有任何影响。 所以，在将光的阴影乘以光照点积之前，我们需要先将点积钳制为 0。使用第 1.2 节中介绍的 x + 表示法，这意味着将负值钳制为零，我们有

![](.gitbook/assets/Snipaste\_2021-10-08\_09-39-35.png)

&#x20;       支持多个光源的着色模型通常会使用公式 5.5 中的一种结构，它更通用，或者公式 5.6，这是基于物理的模型所必需的。 它对于风格化模型也很有利，因为它有助于确保照明的整体一致性，特别是对于背离灯光或有阴影的表面。 然而，有些模型并不适合这种结构； 此类模型将使用公式 5.5 中的结构。

&#x20;       函数 flit() 最简单的选择是使它成为一个恒定的颜色，

![](.gitbook/assets/Snipaste\_2021-10-08\_09-43-30.png)

得到如下着色模型:

![](.gitbook/assets/Snipaste\_2021-10-08\_09-45-14.png)

&#x20;       该模型的点亮部分对应于 Lambertian 着色模型，以 Johann Heinrich Lambert \[967] 命名，他于 1760 年发表了它！ 该模型适用于理想的漫反射表面，即完美无光泽的表面。 我们在此对 Lambert 模型进行稍微简化的解释，第 9 章将对其进行更严格的介绍。 Lambertian 模型可以单独用于简单的着色，它是许多着色模型中的关键构建块。

&#x20;       由式5.3-5.6可知，光源通过两个参数与着色模型相互作用:指向光源的向量l和光线颜色clight。有各种不同类型的光源，主要区别于这两个参数在场景中的变化。

&#x20;       我们接下来将讨论几种流行的光源类型，它们有一个共同点：在给定的表面位置，每个光源仅从一个方向 l 照亮表面。 换句话说，从着色表面位置看到的光源是一个无限小的点。 对于真实世界的灯光来说，严格来说并非如此，但大多数光源相对于它们与被照明表面的距离而言都很小，因此这是一个合理的近似值。 在 7.1.2 和 10.1 节中，我们将讨论从一系列方向照亮表面位置的光源，即“区域光”。

### 5.2.1 平行光 Directional Lights

&#x20;       平行光是最简单的光源模型。 l 和clight在场景中都是恒定的，除了 clight可能会因阴影而衰减。 平行光没有位置。 当然，实际的光源在空间中确实有特定的位置。平行光是抽象的，当到光的距离相对于场景尺寸较大时，它可以很好地工作。 例如，20 英尺外的泛光灯照亮一个小型桌面西洋镜可以表示为定向灯。 另一个例子是几乎所有被太阳照亮的场景，除非所讨论的场景是诸如太阳系内行星之类的场景。

&#x20;       平行光的概念可以稍微扩展以允许在光的方向 l 保持不变的情况下改变 clight 的值。 出于性能或创作的原因，这通常用于将灯光效果绑定到场景的特定部分。 例如，一个区域可以用两个嵌套的（一个在另一个里面）盒形体积来定义，其中 clight 等于 (0, 0, 0) （纯黑色）在外盒外面，里面的内框等于某个常数值 ，并在两个框之间的区域中的那些极端之间平滑地插值。

### 5.2.2 精确光源 Punctual Lights

&#x20;       与平行光不同，Punctual Lights不是准时到达的光源，而是具有位置的光源。 与现实世界的光源不同，这些光源也没有尺寸、形状或大小。 我们使用来自拉丁文 punctus 的术语“punctual”，意思是“点”，指的是所有来源于一个地方的照明来源。 我们使用术语“点光源”来表示一种特定类型的发射器，它向所有方向均等地发光。 因此，点光源和聚光灯是两种不同形式的Punctual Lights。 光方向向量 l 根据当前着色表面点 p0 相对于精确光源的位置 plight 的位置而变化：

![](.gitbook/assets/Snipaste\_2021-10-08\_14-40-27.png)

&#x20;       此等式是向量归一化的一个示例：将向量除以其长度以生成指向同一方向的单位长度向量。 这是另一种常见的着色操作，和我们在上一节中看到的着色操作一样，它是大多数着色语言中的内置函数。 但是，有时需要此操作的中间结果，这需要使用更基本的操作在多个步骤中明确执行规范化。 将此应用于精确光方向计算，我们得到以下结果：

![](.gitbook/assets/Snipaste\_2021-10-08\_15-48-57.png)

&#x20;       由于两个向量的点积等于两个向量的长度与其夹角余弦的乘积，0°的余弦为1.0，因此向量与其自身的点积是其长度的平方。 因此，要找到任何向量的长度，我们只需将其与自身相加并取结果的平方根。

&#x20;       我们需要的中间值是 r，即精确光源与当前阴影点之间的距离。 除了用于对光向量进行归一化之外，还需要使用 r 的值来计算作为距离函数的光颜色clight的衰减（变暗）。 这将在下一节中进一步讨论。

**点/泛光灯 Point/Omni Lights**

&#x20;       ****        向各个方向均匀发射的精确光源称为点光源或泛光灯。 对于点光源，clight 随距离 r 的函数而变化，唯一的变化来源是上面提到的距离衰减。 图 5.5 显示了为什么会发生这种变暗，使用与图 5.4 中的余弦因子演示类似的几何推理。 在给定的表面上，来自点光源的光线之间的间距与从表面到光源的距离成正比。 与图 5.4 中的余弦因子不同，这种间距增加发生在表面的两个维度上，因此光线密度（以及浅色光clight）与距离平方的倒数 1/r2 成正比。 这使我们能够使用单个光属性 clight0 指定 clight 的空间变化，clight0 定义为固定参考距离 r0 处的clight 值：

![](.gitbook/assets/Snipaste\_2021-10-08\_21-43-55.png)

&#x20;        第一个问题发生在相对较小的距离处。 随着 r 的值趋于 0，clight 的值将无限增加。 当 r 达到 0 时，我们将有一个被零除的奇点。 为了解决这个问题，一个常见的修改是在分母 上添加一个小值 ：

![](.gitbook/assets/Snipaste\_2021-10-08\_21-49-34.png)

分母添加的小值的确切值取决于应用； 例如，Unreal 游戏引擎使用 1 cm。

在CryEngine和Frostbite游戏引擎中使用的另一种修改是将r限制到最小值rmin:

![](.gitbook/assets/Snipaste\_2021-10-08\_21-52-04.png)

&#x20;      与前一种方法中使用的有点任意的 ǫ 值不同，rmin 的值具有物理解释：发射光的物理对象的半径。小于 rmin 的 r 值对应于穿透物理光源内部的阴影表面，即 是不可能的。

![图 5.5 ](.gitbook/assets/Snipaste\_2021-10-08\_21-54-54.png)

&#x20;         来自点光源的光线之间的间距与距离 r 成比例地增加。 由于间距增加发生在二维中，因此光线密度（以及光强度）与 1/r2 成比例地减小。

&#x20;        相比之下，平方反比衰减的第二个问题发生在相对较大的距离处。 问题不在于视觉效果，而在于性能。 尽管光强度随着距离不断降低，但它永远不会变为 0。为了高效渲染，希望光强度intensity在某个有限距离处为0（第 20 章）。 有许多不同的方法可以修改平方反比方程来实现这一点。 理想情况下，修改应该引入尽可能少的变化。 为了避免在光的影响的边界处出现尖锐的截止（即变化不够平滑），也最好使修改函数的导数和值在相同距离处达到 0。

&#x20;        一种解决方案是将平方反比方程乘以具有所需属性的windowing函数。 虚幻引擎 \[861] 和 Frostbite \[960] 游戏引擎都使用了一个这样的函数 \[860]：

![](.gitbook/assets/Snipaste\_2021-10-08\_22-03-38.png)

&#x20;        \+2的意思是，如果值是负数，则在平方它之前限制到0。图5.6显示了一个反平方曲线的例子，方程5.14中的windowing函数，以及两者相乘的结果。

![图5.6](.gitbook/assets/Snipaste\_2021-10-08\_22-05-24.png)

&#x20;        该图显示了反平方曲线（使用 ǫ 方法避免奇点，ǫ 值为 1）、公式 5.14 中描述的windowing函数（rmax 设置为 3）和windowing曲线。

&#x20;       应用要求将影响所用方法的选择。 例如，当距离衰减函数以相对较低的空间频率（例如，在光照贴图light map或每个顶点中）采样时，在 rmax 处使导数等于 0 尤为重要。 CryEngine 不使用光照贴图light map或顶点光照，因此它采用了更简单的调整，在 0.8rmax 和 rmax 之间采用线性衰减。

&#x20;      对于某些应用程序，平方反比曲线不是优先事项，因此完全使用一些其他的函数。 将方程 5.11–5.14 概括到以下内容：

![](.gitbook/assets/Snipaste\_2021-10-08\_22-19-19.png)

&#x20;       其中 fdist(r) 是某个距离函数。 此类函数称为距离衰减函数。 在某些情况下，因为性能的原因不使用后平方反比衰减函数。 例如，Just Cause 2 游戏需要计算成本极低的光照。从而引入了易于计算的衰减函数，同时也足够平滑以避免顶点光照瑕疵的函数\[1379]：

![](.gitbook/assets/Snipaste\_2021-10-08\_22-22-59.png)

&#x20;       在其他情况下，衰减函数的选择可能是出于创造性考虑。 例如，用于写实游戏和风格化游戏的虚幻引擎有两种光衰减模式：平方反比模式，如公式 5.12 中所述，以及指数衰减模式，可以进行调整以创建各种衰减曲线 \[1802]。 游戏 Tomb Raider (2013) 的开发人员使用spline-editing工具来创作衰减曲线 \[953]，从而可以更好地控制曲线形状。

**聚光灯 Spotlights**

&#x20;       与点光源不同，几乎所有真实世界光源的照明（illumination）都因方向和距离而异。 这种变化可以表示为方向衰减函数 fdir(l)，它结合距离衰减函数来定义光强度的整体空间变化：

![](.gitbook/assets/Snipaste\_2021-10-08\_22-39-25.png)

&#x20;       fdir(l) 的不同选择可以产生不同的光照效果。 一种重要的效果类型是聚光灯，它以圆锥形投射光线。 聚光灯的方向衰减函数具有围绕聚光灯方向向量 s 的旋转对称性，因此可以表示为 s 与到表面的反向光向量 -l 之间的角度 θs 的函数。 需要反转光向量，因为我们将表面上的 l 定义为指向光，而这里我们需要指向远离光的向量。

&#x20;      大多数spotlight函数使用由θs的余弦组成的表达式，这(正如我们前面所看到的)是阴影中角度的最常见形式。射灯通常有一个本影角θu，将光线限制在这样的范围内，即所有θs≥θu时，fdir(l) = 0。 这个角度可以用与前面看到的最大衰减距离rmax相似的方式进行淘汰。射灯有半影角θp也是很常见的，这定义了一个内锥，在那里光线处于其全部强度。参见图5.7。

![图5.7](.gitbook/assets/Snipaste\_2021-10-16\_09-54-59.png)

&#x20;        聚光灯:θs是从光定义的方向s到向量- l(指向表面的方向)的角度;θp为半影;θu表示为光定义的本影角。

&#x20;      聚光灯使用了各种方向衰减函数，但它们往往是大致相似的。例如，函数fdirF (l)是用在Frostbite游戏引擎\[960]，和功能fdirT (l)用于three.js浏览器图形库\[218]:

![](.gitbook/assets/Snipaste\_2021-10-16\_10-07-46.png)

&#x20;      回想一下，x +是在0和1之间夹紧x的符号，在第1.2节中介绍过。平滑步进函数是一个三次多项式，经常用于光滑插值在阴影。它是大多数着色语言中的内置函数。图5.8显示了到目前为止我们已经讨论过的一些光类型。

![图5.8](.gitbook/assets/Snipaste\_2021-10-16\_10-39-13.png)

&#x20;       图5.8显示了一些类型的灯。从左到右:定向光，没有衰减的点光源，有一个平稳的过渡的聚光灯。注意，点光源向边缘变暗是因为光源和表面之间的角度变化。

**其他精确光源 Other Punctual Lights**

&#x20;         ****          有许多其他方式可以改变一个Punctual Lights的亮度值。

&#x20;       fdir(l)函数并不局限于上面讨论的简单聚光灯衰减函数;它可以代表任何类型的方向变化，包括从真实世界的光源测量的复杂的表格模式。照明工程协会(IES)已经为这种测量定义了标准文件格式。IES简介可从许多照明制造商，并已用于游戏Killzone: Shadow Fall\[379, 380]，以及虚幻\[861]和Frostbite\[960]游戏引擎等。拉加德很好地总结了与解析和使用该文件格式有关的问题\[961]。

&#x20;     《古墓丽影》(2013)\[953]中有一种Punctual Lights，它适用于x, y和z世界轴上的距离独立衰减函数。在《古墓丽影》中，曲线也可以用来改变光照强度，例如，产生闪烁的手电筒。

&#x20;      在第6.9节中，我们将讨论如何通过使用纹理来改变光的强度和颜色。

### 5.2.3 其他光源类型 Other Light Types

&#x20;      directional light和Punctual light的主要特征是如何计算光的方向l。不同类型的光可以通过使用其他方法来计算光的方向来定义。例如，除了前面提到的灯光类型，《古墓丽影》还使用线段作为光源的胶囊灯，而不是点\[953]。对于每个着色像素，以线段上最近点的方向作为光方向l。

&#x20;      只要着色器有l和clight值用于评估着色方程，任何方法都可以用来计算这些值。

&#x20;      到目前为止讨论的光类型是抽象的。实际上，光源有大小和形状，它们从多个方向照亮表面点。 在渲染中，这种灯被称为区域灯，它们在实时应用中的使用正在稳步增加。区域光渲染技术分为两类：模拟由部分遮挡的区域光导致阴影边缘的柔化（第 7.1.2 节）和模拟区域光对表面着色效果的那些（第 10.1 节） .第二类照明对于光滑、镜面般的表面最为明显，在这种情况下，可以从反射中清楚地辨别出光的形状和大小。平行灯和精确光不太可能被废弃，尽管它们不再像过去那样无处不在。已经开发出计算光面积的近似值，其实施成本相对较低，因此得到了更广泛的使用。与过去相比，GPU 性能的提高还允许采用更精细的技术。

## 5.3 实现着色模型 Implementing Shading Models

&#x20;      为了有用，这些着色和光照方程当然必须在代码中实现。在本节中，我们将讨论设计和编写此类实现时的一些关键考虑因素。我们还将浏览一个简单的实现示例。

### 5.3.1 评估频率 Frequency of Evaluation

&#x20;      当设计一个着色实现时，需要根据计算的频率进行划分。首先，确定给定计算的结果在整个draw调用中是否始终是常量。在这种情况下，计算可以由应用程序执行，通常在CPU上，尽管GPU计算着色器可以用于特别昂贵的计算。结果通过着色器的uniform输入传递给图形API。

&#x20;      即使在这个类别中，评估的频率范围也很广，从一次开始。最简单的例子是着色方程中的常量子表达式，但这也适用于基于很少变化的因素的任何计算，如硬件配置和安装选项。这样的着色计算可能会在编译着色器时解决，在这种情况下甚至不需要设置一个uniform着色器输入。或者，计算可以在离线预计算过程中执行，在安装时执行，或者在加载应用程序时执行。

&#x20;      另一种情况是，当着色计算的结果在应用程序运行过程中发生变化，但速度很慢，没有必要每一帧都更新它。例如，在虚拟游戏世界中，光照因素取决于一天中的时间。如果计算是昂贵的，它可能是值得摊销在多个帧。

* 顶点着色vertex shader——评估每个预镶嵌顶点。
* 外壳着色器hull shader——评估每个表面补丁。
* 域着色器domain shader——评估每个后镶嵌顶点
* 几何着色器geometry shader——每个图元的评估。
* 像素着色器pixel shader——每个像素的评估。

&#x20;      实际上，大多数着色计算都是逐像素执行的。 虽然这些通常在像素着色器中实现，但计算着色器实现越来越普遍； 第 20 章将讨论几个例子。其他阶段主要用于几何操作，如变换和变形。 为了理解为什么会这样，我们将比较逐顶点和逐像素着色评估的结果。 在较旧的文本中，这些有时分别称为 Gouraud shading \[578] 和 Phong shading \[1414]，尽管这些术语今天不经常使用。 此比较使用了与公式 5.1 中的模型有些类似的着色模型，但经过修改以适用于多个光源。 当我们详细介绍示例实现时，将在稍后给出完整模型。

&#x20;      图 5.9 显示了对具有广泛顶点密度的模型进行逐像素和逐顶点着色的结果。 对于巨龙来说，一个极其密集的网眼，两者的差别很小。 但是在茶壶上，顶点着色评估会导致有角度的高光等可见错误，而在两个三角形平面上，顶点着色版本显然不正确。 这些错误的原因是着色方程的某些部分，特别是高光，具有在网格表面上非线性变化的值。 这使得它们不适合顶点着色器，其结果在被提供给像素着色器之前在三角形上线性插值。

![图 5.9 ](.gitbook/assets/Snipaste\_2021-10-16\_14-49-23.png)

&#x20;      公式 5.19 中示例着色模型的每像素和每顶点评估的比较，显示在三个不同顶点密度的模型上。 左列显示每像素评估的结果，中列显示每顶点评估，右列显示每个模型的线框渲染以显示顶点密度。 （来自 Computer Graphics Archive \[1172] 的中国龙网格，来自斯坦福 3D 扫描存储库的原始模型。）

&#x20;      原则上，可以在像素着色器中仅计算着色模型的镜面高光部分，而在顶点着色器中计算其余部分。这可能不会导致视觉伪影，理论上会节省一些计算。实际上，这种混合实现通常不是最佳的。着色模型的线性变化部分往往计算成本最低，以这种方式拆分着色计算往往会增加足够的开销，例如重复计算和额外的变化输入，以超过任何好处。&#x20;

&#x20;      正如我们之前提到的，在大多数实现中，顶点着色器负责非着色操作，例如几何变换和变形。生成的几何表面属性转换为适当的坐标系，由顶点着色器写出，在三角形上进行线性插值，并作为不同的着色器输入传递到像素着色器中。如果法线贴图需要，这些属性通常包括表面的位置、表面法线和可选的表面切线向量。

&#x20;       请注意，即使顶点着色器始终生成单位长度的表面法线，插值也可以更改其长度。 请参见图 5.10 的左侧。 出于这个原因，法线需要在像素着色器中重新归一化（缩放到长度 1）。 但是，顶点着色器生成的法线长度仍然很重要。 如果顶点之间的法线长度变化很大，例如，作为顶点混合的副作用，这将扭曲插值。 这可以在图 5.10 的右侧看到。 由于这两种影响，实现通常在插值之前和之后对插值向量进行归一化，即在顶点着色器和像素着色器中。

![图 5.10](<.gitbook/assets/Snipaste\_2021-10-16\_14-56-15 (1).png>)

&#x20;      在图5.10左侧，我们看到跨表面的单位法线的线性插值会产生长度小于 1 的插值向量。 在右侧，我们看到长度明显不同的法线的线性插值会导致插值方向偏向两条法线中较长的一条。

&#x20;      与表面法线不同，指向特定位置的向量（例如点光源的视图向量和精确光源的向量）通常不会插值。相反，插值的表面位置用于在像素着色器中计算这些向量。 除了归一化，正如我们所见，在任何情况下都需要在像素着色器中执行，这些向量中的每一个都通过向量减法计算，这很快。 如果由于某种原因需要对这些向量进行插值，请不要事先对它们进行归一化。 这将产生错误的结果，如图 5.11 所示。

![图 5.11 ](.gitbook/assets/Snipaste\_2021-10-16\_15-01-34.png)

&#x20;      图5.11显示的是两个光向量之间的插值。 在左侧，在插值之前对它们进行归一化会导致插值后方向不正确。 在右侧，对非归一化向量进行插值会产生正确的结果。

&#x20;      前面我们提到顶点着色器将表面几何体转换为“适当的坐标系”。通过uniform变量传递给像素着色器的相机和灯光位置通常由应用程序转换为相同的坐标系。这最大限度地减少了像素着色器为将所有着色模型向量带入同一坐标空间所做的工作。但哪个坐标系是“合适的”坐标系？可能包括全局世界空间以及相机的局部坐标系，或者更罕见的是当前渲染模型的局部坐标系。通常基于性能、灵活性和简单性等系统考虑因素，为渲染系统整体做出选择。例如，如果预期渲染场景包含大量灯光，则可能会选择世界空间以避免变换灯光位置。或者，相机空间可能是首选，以更好地优化与视图向量相关的像素着色器操作并可能提高精度（第 16.6 节）。

&#x20;      尽管大多数着色器实现，包括我们将要讨论的示例实现，都遵循上述一般大纲，当然也有例外。 例如，某些应用程序出于文体原因选择预置着色评估的分面外观。 这种样式通常称为平面着色。 图 5.12 显示了两个示例。

&#x20;      原则上，平面着色可以在几何着色器中执行，但最近的实现通常使用顶点着色器。 这是通过将每个图元的属性与其第一个顶点相关联并禁用顶点值插值来完成的。

### 5.3.2 实现示例 Implementation Example

&#x20;      我们现在将展示一个示例着色模型实现。 如前所述，我们正在实现的着色模型类似于公式 5.1 中的扩展 Gooch 模型，但经过修改以适用于多个光源。 它被描述为：

![](.gitbook/assets/Snipaste\_2021-10-16\_15-11-06.png)

中间计算如下:

![](.gitbook/assets/Snipaste\_2021-10-16\_15-12-35.png)

这个公式符合5.6式中的多光结构，为了方便起见，在此重复：

![](.gitbook/assets/Snipaste\_2021-10-16\_15-15-40.png)

这里有光照的和没光照的是通过调整冷色的未光贡献，使结果看起来更像原来的方程

![](.gitbook/assets/Snipaste\_2021-10-16\_15-16-36.png)

&#x20;      在大多数典型的渲染应用程序中，诸如 csurface 之类的材料属性的变化值将存储在顶点数据中，或者更常见的是，存储在纹理中（第 6 章）。然而，为了使这个示例实现简单，我们将假设 csurface 在整个模型中保持不变。&#x20;

&#x20;      此实现将使用着色器的动态分支功能来循环所有光源。 虽然这种简单的方法可以很好地适用于相当简单的场景，但它不能很好地扩展到具有许多光源的大型和几何复杂的场景。 有效处理大量光的渲染技术将在第 20 章中介绍。此外，为了简单起见，我们将只支持一种类型的光源：点光源。 虽然实现非常简单，但它遵循了早期的最佳实践。

&#x20;      着色模型不是孤立实现的，而是在一个更大的渲染框架的上下文中实现的。这个例子是在一个简单的WebGL 2应用程序中实现的，它是由Tarek Sherif\[1623]修改的“phong -阴影立方体”WebGL 2示例，但同样的原则也适用于更复杂的框架。

&#x20;                                             ...........................

### 5.3.3 材料系统 Material Systems

&#x20;      渲染框架很少只实现单个着色器，就像我们的简单示例一样。通常，需要一个专用系统来处理应用程序使用的各种材质、着色模型和着色器。&#x20;

&#x20;      如前几章所述，着色器是用于 GPU 可编程着色器阶段之一的程序。 因此，它是一种低级图形 API 资源，而不是艺术家可以直接与之交互的东西。 相比之下，材料是面向艺术家的表面视觉外观的封装。 材料有时也描述非视觉方面，例如碰撞属性，我们不会进一步讨论，因为它们超出了本书的范围。

&#x20;      虽然材质是通过着色器实现的，但这并不是简单的一一对应。 在不同的渲染情况下，相同的材质可能会使用不同的着色器。 一个着色器也可以被多个材质共享。 最常见的情况是参数化材料。 在最简单的形式中，材料参数化需要两种类型的材料实体：材料模板和材料实例。 每个材质模板描述一类材质并具有一组参数，这些参数可以根据参数类型分配数值、颜色或纹理值。 每个材质实例对应于一个材质模板以及其所有参数的一组特定值。 一些渲染框架（例如 Unreal Engine \[1802]）允许更复杂的层次结构，材质模板从多个级别的其他模板派生而来。

&#x20;      参数可以在运行时通过将uniform输入传递给着色器程序来解析，或者在编译时通过在着色器编译之前替换值来解析。 一种常见的编译时参数是一个布尔开关，它控制给定材料特征的激活。 这可以由美术师通过材质用户界面中的复选框设置，也可以由材质系统按程序设置，例如，用于降低远距离物体的着色器成本，其中该特征的视觉效果可以忽略不计。

&#x20;       虽然材料参数可能与着色模型的参数一一对应，但情况并非总是如此。 材质可以将给定着色模型参数的值（例如表面颜色）固定为常数值。或者，着色模型参数可以作为采用多个材料参数的一系列复杂操作的结果进行计算，以及 内插顶点或纹理值，作为输入。 在某些情况下，表面位置、表面方向甚至时间等参数也可能会影响计算。 基于表面位置和方向的着色在地形材质中尤为常见。 例如，高度和表面法线可用于控制雪效果，在高海拔水平和几乎水平的表面上混合白色表面颜色。 基于时间的着色在动画材质中很常见，例如闪烁的霓虹灯。

